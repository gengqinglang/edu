# 战略路线排序逻辑说明

**文档版本**: 1.0  
**创建日期**: 2024年12月19日  
**最后更新**: 2024年12月19日

## 📋 概述

本文档详细说明了教育路径规划系统中战略路线的排序逻辑。系统根据用户当前的教育状态，智能排序战略路线，优先推荐与当前状态最匹配、最连贯的教育路径。

## 🎯 排序目标

基于客户当前的教育状态（例如：高中-民办国际学校），优先推荐那些与当前状态最连贯、最匹配的战略路线。排序逻辑主要考虑战略路线与当前状态的匹配度，即战略路线中的路径是否延续了当前的教育体系（国际体系或国内体系）。

## 🔧 排序算法

### 排序优先级

战略路线按以下规则进行排序：

#### 普通战略路线排序
普通战略路线（非"其他个性化路线"和"不可行路线"）按以下三个维度进行排序，优先级从高到低：

1. **平均匹配得分** (最高优先级)
2. **可行性评分** (第二优先级)  
3. **路径数量** (第三优先级)

#### 特殊路线排序
- **其他个性化路线**：不参与匹配度排序，固定放在倒数第二位
- **不可行路线**：不参与匹配度排序，固定放在倒数第一位，且在前端分开展示

### 1. 平均匹配得分计算

#### 1.1 教育水平分类

**国际体系水平**：
- 民办双语
- - 公立国际部
- 民办国际化学校
- 海外高中
- 海外大学
- 海外硕士
- 海外博士

**国内体系水平**：
- 公立
- 普通私立
- 民办普通高中
- 国内公办
- 国内民办
- 中外合作办学
- 国内硕士
- 国内博士

#### 1.2 相似度计算

对于路径中的每个教育阶段水平，计算与当前水平的相似度：

```typescript
function calculateLevelSimilarity(level1, level2) {
  // 如果两个水平相同，相似度为1
  if (level1 === level2) {
    return 1;
  }

  // 判断是否为国际体系
  const level1IsInternational = isInternationalLevel(level1);
  const level2IsInternational = isInternationalLevel(level2);

  // 如果都是国际体系或都是国内体系，相似度为1
  if (level1IsInternational === level2IsInternational) {
    return 1;
  }

  // 如果一个是国际体系，一个是国内体系，相似度为0
  return 0;
}
```

#### 1.3 路径匹配得分

单条路径的匹配得分计算：

```typescript
function calculatePathMatchScore(path, currentLevel) {
  let totalSim = 0;
  
  // 计算路径中每个阶段水平与当前水平的相似度
  for (const node of path.nodes) {
    const level = node.level;
    const sim = calculateLevelSimilarity(level, currentLevel);
    totalSim += sim;
  }
  
  return totalSim / path.nodes.length;
}
```

#### 1.4 战略路线平均匹配得分

战略路线的平均匹配得分：

```typescript
function calculateRouteAverageMatchScore(paths, currentLevel) {
  let totalScore = 0;
  for (const path of paths) {
    totalScore += calculatePathMatchScore(path, currentLevel);
  }
  
  return totalScore / paths.length;
}
```

### 2. 可行性评分

基于路径中所有节点的可行性状态计算：

- **FEASIBLE_HIGH**: 所有节点都是 `feasible`
- **FEASIBLE_MEDIUM**: 有条件可行或较罕见
- **FEASIBLE_LOW**: 不可行或非常罕见

### 3. 路径数量

战略路线中包含的路径总数。

## 📊 排序实现

### 核心排序逻辑

```typescript
// 分离特殊路线和普通路线
const specialRoutes = routes.filter(route => 
  route.id === 'other_paths' || route.id === 'infeasible_paths'
);
const normalRoutes = routes.filter(route => 
  route.id !== 'other_paths' && route.id !== 'infeasible_paths'
);

// 为普通路线计算平均匹配得分
const normalRoutesWithMatchScore = normalRoutes.map(route => ({
  ...route,
  averageMatchScore: matchScoreCalculator.calculateRouteAverageMatchScore(
    route.paths, 
    userInput.currentLevel
  )
}));

// 按匹配度、可行性评分和路径数量排序普通路线
const sortedNormalRoutes = normalRoutesWithMatchScore.sort((a, b) => {
  // 1. 优先按平均匹配得分排序（匹配度高的在前）
  if (a.averageMatchScore !== b.averageMatchScore) {
    return b.averageMatchScore - a.averageMatchScore;
  }
  
  // 2. 其次按可行性评分排序
  if (a.feasibilityScore !== b.feasibilityScore) {
    return b.feasibilityScore - a.feasibilityScore;
  }
  
  // 3. 最后按路径数量排序
  return b.pathCount - a.pathCount;
});

// 特殊路线不参与匹配度排序，按固定顺序排列
const otherPathsRoute = specialRoutes.find(route => route.id === 'other_paths');
const infeasiblePathsRoute = specialRoutes.find(route => route.id === 'infeasible_paths');

// 最终排序：普通路线 + 其他个性化路线 + 不可行路线
const finalRoutes = [...sortedNormalRoutes];

if (otherPathsRoute) {
  finalRoutes.push(otherPathsRoute);
}

if (infeasiblePathsRoute) {
  finalRoutes.push(infeasiblePathsRoute);
}

return finalRoutes;
```

## 🧪 测试用例

### 测试用例1：国际体系用户

**输入**：
- 当前阶段：高中
- 当前年级：1年级
- 当前水平：民办国际化学校
- 目标阶段：研究生

**期望结果**：
- 海外直通路线排在第一位（匹配度 = 1.0）
- 中期转轨路线排在第二位
- 其他路线按可行性排序

### 测试用例2：国内体系用户

**输入**：
- 当前阶段：高中
- 当前年级：1年级
- 当前水平：公立
- 目标阶段：研究生

**期望结果**：
- 国内直达路线排在第一位（匹配度 = 1.0）
- 晚期转轨路线排在第二位
- 其他路线按可行性排序

### 测试用例3：混合体系用户

**输入**：
- 当前阶段：高中
- 当前年级：1年级
- 当前水平：公立国际部
- 目标阶段：研究生

**期望结果**：
- 中期转轨路线排在第一位（匹配度 = 1.0）
- 海外直通路线排在第二位
- 其他路线按可行性排序

## 📈 排序效果示例

### 示例：高中-民办国际化学校 → 研究生

假设有以下战略路线：

| 战略路线 | 平均匹配得分 | 可行性评分 | 路径数量 | 最终排序 |
|---------|-------------|-----------|---------|---------|
| 海外直通路线 | 1.0 | 0.9 | 15 | 1 |
| 中期转轨路线 | 0.8 | 0.8 | 8 | 2 |
| 晚期转轨路线 | 0.6 | 0.7 | 12 | 3 |
| 国内直达路线 | 0.0 | 0.9 | 20 | 4 |
| 回国发展路线 | 0.4 | 0.6 | 5 | 5 |

**排序说明**：
1. 海外直通路线：匹配度最高(1.0)，排第一位
2. 中期转轨路线：匹配度较高(0.8)，排第二位
3. 晚期转轨路线：匹配度中等(0.6)，排第三位
4. 国内直达路线：匹配度最低(0.0)，但可行性高，排第四位
5. 回国发展路线：匹配度和可行性都较低，排第五位

## 🔍 技术实现

### 后端实现

**文件位置**：
- `src/services/MatchScoreCalculator.ts` - 匹配度计算服务
- `src/services/PathClusterer.ts` - 路径聚类和排序服务
- `src/types/index.ts` - 类型定义

**关键类**：
- `MatchScoreCalculatorService` - 匹配度计算
- `PathClustererService` - 路径聚类和排序

### 前端实现

**文件位置**：
- `frontend/js/match-score-calculator.js` - 前端匹配度计算服务
- `frontend/js/path-clusterer.js` - 前端路径聚类服务
- `frontend/js/app.js` - 前端显示逻辑
- `frontend/css/style.css` - 样式定义
- `frontend/index.html` - 页面引用

**关键类**：
- `MatchScoreCalculatorService` - 前端匹配度计算
- `PathClustererService` - 前端路径聚类和排序
- `EducationPathApp` - 前端应用主类

**前端显示逻辑**：
- 普通战略路线显示在"推荐战略路线"区域
- 不可行路线显示在"不可行路径参考"区域，有独立的样式和警告提示
- 不可行路线卡片有特殊的红色主题和警告图标

## 📝 配置说明

### 国际体系水平配置

如需修改国际体系水平的定义，请更新以下文件中的配置：

**后端**：`src/services/MatchScoreCalculator.ts`
```typescript
private readonly internationalLevels: Set<EducationLevel> = new Set([
  '民办双语',
  '',
  '公立国际部',
  '民办国际化学校',
  '海外高中',
  '海外大学',
  '海外硕士',
  '海外博士'
]);
```

**前端**：`frontend/js/match-score-calculator.js`
```javascript
this.internationalLevels = new Set([
  '民办双语',
  '',
  '公立国际部',
  '民办国际化学校',
  '海外高中',
  '海外大学',
  '海外硕士',
  '海外博士'
]);
```

### 国内体系水平配置

同样，国内体系水平的配置也需要在前后端同步更新。

## 🚀 未来扩展

### 可能的改进方向

1. **更精细的匹配度计算**
   - 考虑教育阶段的连续性
   - 考虑转轨的难度系数
   - 考虑地区差异

2. **个性化权重**
   - 允许用户自定义排序权重
   - 基于用户偏好调整排序逻辑

3. **动态配置**
   - 将排序规则配置化
   - 支持运行时调整排序参数

4. **机器学习优化**
   - 基于用户行为数据优化排序
   - 个性化推荐算法

## 📚 相关文档

- [标签系统说明.md](./标签系统说明.md) - 标签系统详细说明
- [战略路线映射关系.md](./战略路线映射关系.md) - 战略路线分类规则
- [今日工作成果总结.md](./今日工作成果总结.md) - 开发工作总结

## 🔧 维护说明

### 代码维护

1. **前后端同步**：修改排序逻辑时，需要同时更新后端TypeScript代码和前端JavaScript代码
2. **类型安全**：确保类型定义的一致性
3. **测试覆盖**：添加单元测试验证排序逻辑的正确性

### 性能优化

1. **缓存机制**：对匹配度计算结果进行缓存
2. **批量计算**：优化大量路径的匹配度计算
3. **异步处理**：对于复杂计算使用异步处理

---

**备注**：本文档记录了战略路线排序逻辑的完整实现，包括算法原理、技术实现、测试用例和配置说明。如需修改排序逻辑，请参考本文档并确保前后端代码的一致性。
